<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forjamento de Espada - Deformação 2D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            color: #f1c40f;
            font-family: Arial, Helvetica, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background-color: #222;
            border: 5px solid #444;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            overflow: hidden;
        }
        
        .canvas-container {
            position: absolute;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .template-label, .forge-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: #f1c40f;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        .template-label {
            top: 10px;
            left: 10px;
        }
        
        .forge-label {
            bottom: 10px;
            left: 10px;
        }
        
        .hammers-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #3a2410;
            border: 2px solid #5d4220;
            border-radius: 5px;
            padding: 5px 10px;
            margin-right: 10px;
        }
        
        .hammers-label {
            font-size: 14px;
            color: #ce9e51;
        }
        
        .hammers-value {
            font-size: 24px;
            color: #f1c40f;
            font-weight: bold;
        }
        
        .game-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: #333;
            border-bottom: 3px solid #555;
            display: flex;
            align-items: center;
            padding: 0 15px;
            z-index: 10;
        }
        
        .game-title {
            font-size: 24px;
            color: #f1c40f;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
            margin: 0;
            flex-grow: 1;
        }
        
        .hammer-selection {
            position: absolute;
            left: 20px;
            top: 20px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 5px;
            width: 100px;
            padding: 10px;
            pointer-events: auto;
            z-index: 10;
        }
        
        .hammer-option {
            margin: 5px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            font-size: 14px;
            text-align: center;
            transition: background-color 0.2s;
        }
        
        .hammer-option:hover {
            background-color: #444;
        }
        
        .hammer-option.selected {
            background-color: #666;
            color: #f1c40f;
        }
        
        .message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #f1c40f;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 20;
        }
        
        .message.show {
            opacity: 1;
        }
        
        .button {
            background-color: #444;
            border: none;
            color: #f1c40f;
            padding: 8px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
            font-family: Arial, Helvetica, sans-serif;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: #555;
        }
        
        .controls {
            position: absolute;
            right: 20px;
            top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            z-index: 10;
        }
        
        .progress-bar {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #f1c40f;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 14px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
        }
        
        .level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #f1c40f;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }
        
        .level-complete h2 {
            font-size: 24px;
            margin-top: 0;
        }
        
        .level-complete p {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="game-header">
            <h1 class="game-title">CEREMONIAL SWORD</h1>
            <div class="hammers-container">
                <div class="hammers-label">Marteladas:</div>
                <div class="hammers-value" id="hammers-remaining">35</div>
            </div>
        </div>
        
        <div id="canvas-container" class="canvas-container">
            <div class="template-label">MODELO DA ESPADA (OBJETIVO)</div>
            <div class="forge-label">METAL PARA FORJAR (CLIQUE PARA MARTELAR)</div>
            <div class="click-instruction">
                Clique nas bordas superior e inferior para martelar e forjar a espada.
            </div>
        </div>
        
        <div class="hammer-selection">
            <div class="hammer-option selected" data-hammer="hard">
                <span class="hammer-name">Hard</span>
            </div>
            <div class="hammer-option" data-hammer="medium">
                <span class="hammer-name">Medium</span>
            </div>
            <div class="hammer-option" data-hammer="soft">
                <span class="hammer-name">Soft</span>
            </div>
            <div class="hammer-option" data-hammer="careful">
                <span class="hammer-name">Careful</span>
            </div>
        </div>
        
        <div class="controls">
            <button class="button" id="check-button">Check Sword</button>
            <button class="button" id="reset-button">Reset</button>
            <button class="button" id="next-level" disabled>Next Level</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
            <div class="progress-text">Match: <span id="match-percentage">0</span>%</div>
        </div>
        
        <div class="message" id="message"></div>
        
        <div class="level-complete" id="level-complete">
            <h2>Level Complete!</h2>
            <p>You've successfully forged the ceremonial sword.</p>
            <button class="button" id="next-level-popup">Next Level</button>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.154.0/three.module.min.js"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        
        // Configuração do jogo
        const config = {
            currentLevel: 1,
            totalLevels: 3,
            matchThreshold: 85, // 85% de correspondência necessária para sucesso
            gridSizeX: 10, // 10 divisões = 11 pontos
            gridSizeY: 5,  // Número de divisões verticais
            maxDeformation: 50, // Valor máximo de deformação em pixels
            totalHammers: 35,   // Número total de marteladas disponíveis
            hammerTypes: {
                hard: { strength: 0.08, radius: 0.6, color: '#ff4500', hammersUsed: 1 },    // Deformação forte
                medium: { strength: 0.05, radius: 0.5, color: '#ffa500', hammersUsed: 1 },  // Deformação média
                soft: { strength: 0.03, radius: 0.4, color: '#ffcc00', hammersUsed: 1 },    // Deformação leve
                careful: { strength: 0.01, radius: 0.3, color: '#98fb98', hammersUsed: 1 }  // Deformação mínima
            }
        };
        
        // Estado do jogo
        const gameState = {
            selectedHammer: 'hard',
            levelCompleted: false,
            matchPercentage: 0,
            hoveredPoint: null,
            hammersRemaining: config.totalHammers
        };
        
        // Elementos DOM
        const canvasContainer = document.getElementById('canvas-container');
        const matchPercentageElement = document.getElementById('match-percentage');
        const progressFillElement = document.getElementById('progress-fill');
        const messageElement = document.getElementById('message');
        const checkButton = document.getElementById('check-button');
        const resetButton = document.getElementById('reset-button');
        const nextLevelButton = document.getElementById('next-level');
        const nextLevelPopupButton = document.getElementById('next-level-popup');
        const levelCompleteElement = document.getElementById('level-complete');
        const hammerOptions = document.querySelectorAll('.hammer-option');
        
        // Variáveis Three.js
        let scene, camera, renderer, raycaster, mouse;
        let targetMesh, metalMesh;
        let width, height;
        
        // Variáveis para os pontos clicáveis
        let hammerPoints = [];
        
        // Definições de espadas usando valores de 0-10 (0 = deformação máxima, 10 = sem deformação)
        // Cada espada é definida por um array de valores para borda superior e inferior
        const swordDefinitions = [
            // Nível 1: Espada básica
            {
                name: "Espada Básica",
                top: [10, 10, 10, 9, 8, 8, 9, 7, 5, 3, 1],
                bottom: [10, 10, 10, 9, 8, 8, 9, 7, 5, 3, 1]
            },
            // Nível 2: Espada com guarda
            {
                name: "Espada com Guarda",
                top: [8, 9, 10, 5, 8, 10, 8, 7, 5, 3, 1],
                bottom: [8, 9, 10, 5, 8, 10, 8, 7, 5, 3, 1]
            },
            // Nível 3: Espada ornamentada
            {
                name: "Espada Ornamentada",
                top: [6, 7, 9, 3, 9, 10, 8, 6, 4, 2, 0],
                bottom: [6, 7, 9, 3, 9, 10, 8, 6, 4, 2, 0]
            }
        ];
        
        // Iniciar o jogo
        function initGame() {
            // Mostrar tela de instruções antes de começar
            const instructionsHTML = `
                <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
                            background-color: rgba(0,0,0,0.8); z-index: 100; display: flex; 
                            flex-direction: column; justify-content: center; align-items: center;
                            text-align: center; padding: 20px; color: #f1c40f;">
                    <h2>Como Jogar - Forjamento de Espada Cerimonial</h2>
                    <div style="max-width: 600px; margin: 20px; line-height: 1.5;">
                        <p><strong>OBJETIVO:</strong> Forjar a espada martelando nas bordas superior e inferior para criar o contorno correto.</p>
                        <p><strong>COMO JOGAR:</strong></p>
                        <ul style="text-align: left; list-style-type: none; padding: 0;">
                            <li>► O <strong>MODELO</strong> no topo mostra a forma da espada que você deve alcançar.</li>
                            <li>► Clique nas <strong>BORDAS</strong> do metal para martelar e deformar em direção ao centro.</li>
                            <li>► Cada martelo tem efeitos diferentes:</li>
                            <li>&nbsp;&nbsp;&nbsp;• <strong>HARD</strong>: Deformação forte, área maior</li>
                            <li>&nbsp;&nbsp;&nbsp;• <strong>MEDIUM</strong>: Deformação média</li>
                            <li>&nbsp;&nbsp;&nbsp;• <strong>SOFT</strong>: Deformação leve</li>
                            <li>&nbsp;&nbsp;&nbsp;• <strong>CAREFUL</strong>: Deformação mínima, área menor</li>
                        </ul>
                <p><strong>DICA:</strong> Use martelos fortes no início para aproximar a forma e depois use martelos mais suaves para os ajustes finos. Valores de 0-10 indicam o nível de deformação de cada ponto.</p>
                    </div>
                    <button id="start-game" style="padding: 10px 20px; background-color: #f1c40f; 
                                               color: #000; border: none; font-size: 18px; 
                                               cursor: pointer; border-radius: 5px;">
                        COMEÇAR A FORJAR
                    </button>
                </div>
            `;
            
            // Criar elemento para as instruções
            const instructionsElement = document.createElement('div');
            instructionsElement.innerHTML = instructionsHTML;
            document.getElementById('game-container').appendChild(instructionsElement);
            
            // Botão para iniciar o jogo após ler as instruções
            document.getElementById('start-game').addEventListener('click', () => {
                instructionsElement.remove();
                startGame();
            });
        }
        
        // Iniciar o jogo após as instruções
        function startGame() {
            // Configurar eventos
            setupEventListeners();
            
            // Inicializar Three.js
            initThreeJS();
            
            // Carregar o primeiro nível
            loadLevel(config.currentLevel);
            
            // Iniciar loop de renderização
            animate();
        }
        
        // Configurar event listeners
        function setupEventListeners() {
            // Escolha do martelo
            hammerOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remover seleção atual
                    document.querySelector('.hammer-option.selected').classList.remove('selected');
                    
                    // Selecionar novo martelo
                    option.classList.add('selected');
                    gameState.selectedHammer = option.dataset.hammer;
                    
                    showMessage(`Martelo ${gameState.selectedHammer.toUpperCase()} selecionado`);
                });
            });
            
            // Botão de verificação
            checkButton.addEventListener('click', checkSword);
            
            // Botão de reset
            resetButton.addEventListener('click', () => loadLevel(config.currentLevel));
            
            // Botão de próximo nível
            nextLevelButton.addEventListener('click', nextLevel);
            nextLevelPopupButton.addEventListener('click', nextLevel);
        }
        
        // Inicializar Three.js
        function initThreeJS() {
            // Obter dimensões do contêiner
            const containerRect = canvasContainer.getBoundingClientRect();
            width = containerRect.width;
            height = containerRect.height;
            
            // Criar cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Criar câmera ortográfica
            camera = new THREE.OrthographicCamera(
                width / -2, width / 2, height / 2, height / -2, 1, 1000
            );
            camera.position.z = 10;
            
            // Criar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);
            
            // Raycaster para detecção de cliques
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Adicionar eventos
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            console.log("Three.js inicializado");
        }
        
        // Carregar nível
        function loadLevel(level) {
            // Atualizar estado do jogo
            gameState.levelCompleted = false;
            gameState.matchPercentage = 0;
            gameState.hammersRemaining = config.totalHammers;
            nextLevelButton.disabled = true;
            levelCompleteElement.style.display = 'none';
            
            // Atualizar contagem de marteladas
            updateHammersDisplay();
            
            // Remover meshs existentes
            if (targetMesh) scene.remove(targetMesh);
            if (metalMesh) scene.remove(metalMesh);
            
            // Limpar pontos clicáveis
            hammerPoints.forEach(point => {
                if (point.mesh) scene.remove(point.mesh);
            });
            hammerPoints = [];
            
            // Criar modelo alvo
            createTargetMesh(level);
            
            // Criar metal para forjar
            createMetalMesh();
            
            // Atualizar porcentagem de correspondência
            updateMatchPercentage();
            
            // Mostrar mensagem
            showMessage(`Nível ${level}: Comece a forjar!`);
            
            console.log(`Nível ${level} carregado`);
        }
        
        // Atualizar display de marteladas
        function updateHammersDisplay() {
            const hammersElement = document.getElementById('hammers-remaining');
            hammersElement.textContent = gameState.hammersRemaining;
            
            // Mudar cor baseado na quantidade restante
            if (gameState.hammersRemaining <= 5) {
                hammersElement.style.color = '#e74c3c'; // Vermelho
            } else if (gameState.hammersRemaining <= 10) {
                hammersElement.style.color = '#f39c12'; // Laranja
            } else {
                hammersElement.style.color = '#f1c40f'; // Amarelo (padrão)
            }
        }
        
        // Converter valores de deformação (0-10) para coordenadas reais
        function deformationToCoordinate(value, isTop) {
            // 10 = sem deformação (posição original na borda)
            // 0 = deformação máxima (movimento completo até o centro)
            
            // Calcular a porcentagem de deformação
            const deformationPercent = (10 - value) / 10;
            
            // Calcular a coordenada Y
            // isTop determina se é a borda superior (true) ou inferior (false)
            const originalY = isTop ? 50 : -50; // Posição original na borda
            const centerY = 0; // Centro da malha
            
            // Interpolar entre a posição original e o centro
            return originalY + (centerY - originalY) * deformationPercent * (config.maxDeformation / 50);
        }
        
        // Criar modelo alvo
        function createTargetMesh(level) {
            const swordDef = swordDefinitions[level - 1];
            
            // Criar geometria
            const shape = new THREE.Shape();
            
            // Iniciar no primeiro ponto da borda superior
            const width = 400;
            const numPoints = swordDef.top.length;
            
            // Converter o primeiro valor para coordenada X,Y
            const firstXPos = (-width / 2);
            const firstYPos = deformationToCoordinate(swordDef.top[0], true);
            
            shape.moveTo(firstXPos, firstYPos);
            
            // Adicionar linha para cada ponto na borda superior
            for (let i = 1; i < numPoints; i++) {
                const xPos = (-width / 2) + (i / (numPoints - 1)) * width;
                const yPos = deformationToCoordinate(swordDef.top[i], true);
                shape.lineTo(xPos, yPos);
            }
            
            // Adicionar linha para cada ponto na borda inferior (na ordem inversa)
            for (let i = numPoints - 1; i >= 0; i--) {
                const xPos = (-width / 2) + (i / (numPoints - 1)) * width;
                const yPos = deformationToCoordinate(swordDef.bottom[i], false);
                shape.lineTo(xPos, yPos);
            }
            
            // Fechar o shape
            shape.closePath();
            
            // Criar geometria a partir do shape
            const geometry = new THREE.ShapeGeometry(shape);
            
            // Criar material
            const material = new THREE.MeshBasicMaterial({
                color: 0x999999,
                wireframe: false,
                side: THREE.DoubleSide
            });
            
            // Criar mesh
            targetMesh = new THREE.Mesh(geometry, material);
            
            // Posicionar no topo da tela
            targetMesh.position.y = 120;
            
            // Adicionar à cena
            scene.add(targetMesh);
            
            // Adicionar linhas para melhor visualização
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material.color.set(0xff0000);
            targetMesh.add(line);
            
            // Mostrar o nome da espada
            showMessage(`Forje a ${swordDef.name}!`);
        }
        
        // Criar malha de metal para forjar
        function createMetalMesh() {
            // Criar geometria inicial (retângulo)
            const width = 400;
            const height = 100;
            
            // Criar malha de pontos para a deformação
            const points = [];
            const numPointsX = config.gridSizeX + 1;
            const numPointsY = config.gridSizeY + 1;
            
            for (let y = 0; y < numPointsY; y++) {
                for (let x = 0; x < numPointsX; x++) {
                    // Converter para coordenadas de -width/2 a width/2, -height/2 a height/2
                    const xPos = (x / (numPointsX - 1) - 0.5) * width;
                    const yPos = (y / (numPointsY - 1) - 0.5) * height;
                    
                    points.push(new THREE.Vector3(xPos, yPos, 0));
                }
            }
            
            // Criar faces (triângulos) para a malha
            const indices = [];
            for (let y = 0; y < numPointsY - 1; y++) {
                for (let x = 0; x < numPointsX - 1; x++) {
                    const a = y * numPointsX + x;
                    const b = y * numPointsX + x + 1;
                    const c = (y + 1) * numPointsX + x;
                    const d = (y + 1) * numPointsX + x + 1;
                    
                    // Criar dois triângulos para formar um quadrado
                    indices.push(a, b, c);
                    indices.push(c, b, d);
                }
            }
            
            // Criar geometria personalizada
            const geometry = new THREE.BufferGeometry();
            
            // Converter pontos para array de posições
            const positions = new Float32Array(points.length * 3);
            for (let i = 0; i < points.length; i++) {
                positions[i * 3] = points[i].x;
                positions[i * 3 + 1] = points[i].y;
                positions[i * 3 + 2] = points[i].z;
            }
            
            // Configurar atributos da geometria
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.computeVertexNormals();
            
            // Criar material
            const material = new THREE.MeshBasicMaterial({
                color: 0xcccccc,
                wireframe: false,
                side: THREE.DoubleSide
            });
            
            // Criar mesh
            metalMesh = new THREE.Mesh(geometry, material);
            
            // Posicionar na parte inferior da tela
            metalMesh.position.y = -120;
            
            // Adicionar à cena
            scene.add(metalMesh);
            
            // Adicionar wireframe para visualização
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material.color.set(0xffff00);
            metalMesh.add(line);
            
            // Criar pontos de martelo nas bordas
            createHammerPoints();
        }
        
        // Criar pontos clicáveis para martelar
        function createHammerPoints() {
            const numPointsX = config.gridSizeX + 1;
            const numPointsY = config.gridSizeY + 1;
            const pointGeometry = new THREE.CircleGeometry(8, 16); // Aumentado para melhor visualização
            
            // Criar pontos na borda superior
            for (let x = 0; x < numPointsX; x++) {
                const xPos = (x / (numPointsX - 1) - 0.5) * 400;
                const yPos = 50; // Borda superior
                
                // Criar ponto visual
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff3333,
                    transparent: true,
                    opacity: 0.7
                });
                
                const pointMesh = new THREE.Mesh(pointGeometry, material);
                pointMesh.position.set(xPos, yPos, 0.1);
                
                // Adicionar à cena
                metalMesh.add(pointMesh);
                
                // Armazenar para referência
                hammerPoints.push({
                    x: xPos,
                    y: yPos,
                    mesh: pointMesh,
                    index: x,
                    edge: 'top'
                });
            }
            
            // Criar pontos na borda inferior
            for (let x = 0; x < numPointsX; x++) {
                const xPos = (x / (numPointsX - 1) - 0.5) * 400;
                const yPos = -50; // Borda inferior
                
                // Criar ponto visual
                const material = new THREE.MeshBasicMaterial({
                    color: 0x3333ff,
                    transparent: true,
                    opacity: 0.7
                });
                
                const pointMesh = new THREE.Mesh(pointGeometry, material);
                pointMesh.position.set(xPos, yPos, 0.1);
                
                // Adicionar à cena
                metalMesh.add(pointMesh);
                
                // Armazenar para referência
                hammerPoints.push({
                    x: xPos,
                    y: yPos,
                    mesh: pointMesh,
                    index: x,
                    edge: 'bottom'
                });
            }
        }
        
        // Tratar movimento do mouse
        function onMouseMove(event) {
            // Ignorar se o nível já foi completado
            if (gameState.levelCompleted) return;
            
            // Calcular posição do mouse normalizada
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Atualizar raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Verificar interseção com os pontos de martelo
            const intersects = [];
            hammerPoints.forEach(point => {
                if (point.mesh) {
                    const meshIntersects = raycaster.intersectObject(point.mesh);
                    if (meshIntersects.length > 0) {
                        intersects.push({ point });
                    }
                }
            });
            
            // Resetar hover em todos os pontos
            hammerPoints.forEach(point => {
                if (point.mesh) {
                    point.mesh.material.opacity = 0.7;
                    point.mesh.scale.set(1, 1, 1);
                    
                    // Restaurar cor original
                    if (point.edge === 'top') {
                        point.mesh.material.color.set(0xff3333);
                    } else {
                        point.mesh.material.color.set(0x3333ff);
                    }
                }
            });
            
            // Destacar o ponto sob o mouse
            if (intersects.length > 0) {
                const hoveredPoint = intersects[0].point;
                hoveredPoint.mesh.material.opacity = 1.0;
                hoveredPoint.mesh.scale.set(1.5, 1.5, 1.5);
                
                // Alterar cor baseado no martelo selecionado
                const hammerColor = config.hammerTypes[gameState.selectedHammer].color;
                hoveredPoint.mesh.material.color.set(hammerColor);
                
                gameState.hoveredPoint = hoveredPoint;
                
                // Mudar cursor para mostrar que é clicável
                renderer.domElement.style.cursor = 'pointer';
            } else {
                gameState.hoveredPoint = null;
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        // Tratar clique do mouse
        function onMouseClick(event) {
            // Ignorar se o nível já foi completado
            if (gameState.levelCompleted) return;
            
            // Se temos um ponto destacado, aplicar martelada
            if (gameState.hoveredPoint) {
                applyHammerAtPoint(gameState.hoveredPoint);
            }
        }
        
        // Aplicar efeito de martelada em um ponto
        function applyHammerAtPoint(point) {
            // Verificar se ainda há marteladas disponíveis
            if (gameState.hammersRemaining <= 0) {
                showMessage("Você não tem mais marteladas disponíveis!", 'warning');
                return;
            }
            
            // Obter o tipo de martelo selecionado
            const hammer = config.hammerTypes[gameState.selectedHammer];
            
            // Reduzir o número de marteladas disponíveis
            gameState.hammersRemaining -= hammer.hammersUsed;
            updateHammersDisplay();
            
            // Obter a posição dos vértices da malha
            const positions = metalMesh.geometry.attributes.position.array;
            
            // Obter raio do martelo (modificar vértices até esta distância)
            const hammerRadius = hammer.radius * 100; // Ajustar para escala do modelo
            
            // Força da deformação
            const strength = hammer.strength;
            
            // Para cada vértice na malha
            const numPointsX = config.gridSizeX + 1;
            const numPointsY = config.gridSizeY + 1;
            
            for (let i = 0; i < numPointsX * numPointsY; i++) {
                // Obter posição atual do vértice
                const vx = positions[i * 3];
                const vy = positions[i * 3 + 1];
                
                // Calcular distância ao ponto de martelo
                const dx = vx - point.x;
                const dy = vy - point.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Se o vértice está dentro do raio do martelo
                if (distance < hammerRadius) {
                    // Calcular fator de deformação (mais forte no centro, diminui com a distância)
                    const deformFactor = 1.0 - distance / hammerRadius;
                    
                    // Mover o vértice em direção ao centro da malha
                    const moveDirection = point.edge === 'top' ? -1 : 1; // Direção baseada na borda
                    const moveAmount = strength * 100 * deformFactor * moveDirection;
                    
                    // Aplicar movimento
                    positions[i * 3 + 1] += moveAmount;
                }
            }
            
            // Marcar a geometria para atualização
            metalMesh.geometry.attributes.position.needsUpdate = true;
            
            // Atualizar normais
            metalMesh.geometry.computeVertexNormals();
            
            // Atualizar correspondência
            updateMatchPercentage();
            
            // Efeito visual da martelada
            showHammerEffect(point, hammer);
            
            // Verificar se acabaram as marteladas
            if (gameState.hammersRemaining <= 0) {
                showMessage("Acabaram suas marteladas! Verificando resultado...", 'warning');
                setTimeout(checkSword, 1500);
            }
        }
        
        // Mostrar efeito visual da martelada
        function showHammerEffect(point, hammer) {
            // Criar geometria para o efeito
            const effectGeometry = new THREE.CircleGeometry(hammer.radius * 50, 32);
            
            // Material para o efeito
            const effectMaterial = new THREE.MeshBasicMaterial({
                color: hammer.color,
                transparent: true,
                opacity: 0.7
            });
            
            // Criar mesh
            const effect = new THREE.Mesh(effectGeometry, effectMaterial);
            effect.position.set(point.x, point.y, 0.2);
            
            // Adicionar à malha de metal
            metalMesh.add(effect);
            
            // Remover após um tempo
            setTimeout(() => {
                metalMesh.remove(effect);
                effectGeometry.dispose();
                effectMaterial.dispose();
            }, 300);
        }
        
        // Atualizar porcentagem de correspondência
        function updateMatchPercentage() {
            const positions = metalMesh.geometry.attributes.position.array;
            const numPointsX = config.gridSizeX + 1;
            const numPointsY = config.gridSizeY + 1;
            
            // Espada do nível atual
            const swordDef = swordDefinitions[config.currentLevel - 1];
            
            let totalError = 0;
            
            // Verificar erro na borda superior
            for (let x = 0; x < numPointsX; x++) {
                // Índice do vértice na borda superior
                const vertexIndex = x * 3;
                
                // Posição Y atual
                const currentY = positions[vertexIndex + 1];
                
                // Posição Y alvo baseada no valor de deformação
                const targetY = deformationToCoordinate(swordDef.top[x], true);
                
                // Calcular erro absoluto
                const error = Math.abs(currentY - targetY);
                totalError += error;
            }
            
            // Verificar erro na borda inferior
            for (let x = 0; x < numPointsX; x++) {
                // Índice do vértice na borda inferior
                const vertexIndex = (config.gridSizeY * numPointsX + x) * 3;
                
                // Posição Y atual
                const currentY = positions[vertexIndex + 1];
                
                // Posição Y alvo baseada no valor de deformação
                const targetY = deformationToCoordinate(swordDef.bottom[x], false);
                
                // Calcular erro absoluto
                const error = Math.abs(currentY - targetY);
                totalError += error;
            }
            
            // Calcular erro máximo possível para normalização
            // Considera o movimento máximo possível dos pontos (da borda ao centro)
            const maxPossibleError = numPointsX * 2 * 50; // 50 é a distância máxima de deslocamento
            
            // Calcular porcentagem de correspondência (inverso do erro normalizado)
            gameState.matchPercentage = Math.max(0, 100 - (totalError / maxPossibleError * 200));
            
            // Arredondar para inteiro
            gameState.matchPercentage = Math.round(gameState.matchPercentage);
            
            // Limitar a 100%
            gameState.matchPercentage = Math.min(100, gameState.matchPercentage);
            
            // Atualizar UI
            matchPercentageElement.textContent = gameState.matchPercentage;
            progressFillElement.style.width = `${gameState.matchPercentage}%`;
            
            // Colorir barra de progresso
            if (gameState.matchPercentage < 50) {
                progressFillElement.style.backgroundColor = '#e74c3c'; // Vermelho
            } else if (gameState.matchPercentage < config.matchThreshold) {
                progressFillElement.style.backgroundColor = '#f39c12'; // Laranja
            } else {
                progressFillElement.style.backgroundColor = '#2ecc71'; // Verde
            }
        }
        
        // Verificar se a espada está pronta
        function checkSword() {
            // Atualizar porcentagem uma última vez
            updateMatchPercentage();
            
            if (gameState.matchPercentage >= config.matchThreshold) {
                // Concluído com sucesso
                gameState.levelCompleted = true;
                nextLevelButton.disabled = false;
                
                // Obter nome da espada atual
                const swordName = swordDefinitions[config.currentLevel - 1].name;
                
                // Mostrar mensagem de sucesso
                showMessage(`${swordName} forjada com sucesso! Correspondência: ${gameState.matchPercentage}%`);
                
                // Mostrar popup de nível completo
                levelCompleteElement.style.display = 'block';
            } else {
                // Ainda não está pronto
                showMessage(`A espada tem apenas ${gameState.matchPercentage}% de correspondência. Continue tentando!`);
            }
        }
        
        // Passar para o próximo nível
        function nextLevel() {
            // Verificar se o nível está completo
            if (!gameState.levelCompleted) return;
            
            // Incrementar nível
            config.currentLevel++;
            
            // Verificar se há mais níveis
            if (config.currentLevel > config.totalLevels) {
                // Jogo completo
                showMessage("Parabéns! Você completou todos os níveis!");
                
                // Reiniciar para o primeiro nível
                config.currentLevel = 1;
            }
            
            // Carregar o próximo nível
            loadLevel(config.currentLevel);
            
            // Esconder popup
            levelCompleteElement.style.display = 'none';
        }
        
        // Mostrar mensagem
        function showMessage(text, type = 'info') {
            messageElement.textContent = text;
            messageElement.className = 'message';
            
            if (text) {
                messageElement.classList.add('show', type);
                
                // Remover após alguns segundos (exceto para mensagens críticas)
                if (type !== 'success') {
                    setTimeout(() => {
                        messageElement.classList.remove('show');
                    }, 3000);
                }
            }
        }
        
        // Loop de animação
        function animate() {
            requestAnimationFrame(animate);
            
            // Renderizar cena
            renderer.render(scene, camera);
        }
        
        // Iniciar o jogo quando a página carregar
        window.addEventListener('load', initGame);
    </script>
</body>
</html>